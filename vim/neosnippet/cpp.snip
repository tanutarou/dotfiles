include c.snip

# #include <...>
snippet inc
alias   #inc, #include
    #include <${1:iostream}>${0}
# #include "..."
snippet inc2
alias   #inc2, #include2
    #include "${1}"${0}

snippet     template
abbr        template <T>
    template<typename ${1:T}> 

snippet     class
abbr        class {}
    class ${1:#:name} {
        ${2}
    public:
        $1(${3});
    };
    $1::$1($3) {
        ${0:TARGET}
    }

snippet     class-without-constructor
abbr        class {}
    class ${1:#:name} {
        ${2}
    };

snippet     try
abbr        try catch
    try {
        ${1:TARGET}
    } catch (${2:e:xception}) {
        ${3}
    }

# range based for ( C++11 feature )
snippet     for_CPP11
abbr        for (:) {}
    for (${1:auto&& }${2:var} : ${3:container}) {
        ${0:TARGET}
    }

# lambda expression ( C++11 feature )
snippet     lambda
abbr        [](){}
    [${1}](${2})${3}{ ${4:TARGET} }

# scoped enumeration ( C++11 feature )
snippet     enum_scoped
abbr        enum struct {}
    enum struct { ${1:TARGET} }

# static assert ( C++11 feature )
snippet     static_assert
abbr        static_assert(,"")
    static_assert( ${1}, "${2}" );${0}

delete      namespace
snippet     namespace
abbr        namespace {}
options     head
    namespace ${1:#:name} {
        ${0:TARGET}
    } // namespace $1

snippet     static_cast
abbr        static_cast<>()
    static_cast<${1}>(${2})${0}

snippet     reinterpret_cast
abbr        reinterpret_cast<>()
    reinterpret_cast<${1}>(${2})${0}

snippet     const_cast
abbr        const_cast<>()
    const_cast<${1}>(${2})${0}

snippet     dynamic_cast
abbr        dynamic_cast<>()
    dynamic_cast<${1}>(${2})${0}

snippet     helloworld
abbr        #include<iostream> int main...
    #include <iostream>

    int main(int argc, char const* argv[])
    {
        std::cout << "hello, world!" << std::endl;
        return 0;
    }

snippet     p
options     head
  std::cout << ${0:TARGET} << std::endl;

snippet unionfind
    int par[MAX_N], tree_rank[MAX_N];
    void init(int n){
        for(int i=0; i<n; i++){
            par[i] = i;
            tree_rank[i] = 0;
        }
    }

    int root(int x){
        return par[x] == x ? x : par[x] = root(par[x]);
    }

    bool same(int x, int y){
        return root(x) == root(y);
    }

    void unite(int x, int y){
        x = root(x);
        y = root(y);
        if(x == y) return;

        if(tree_rank[x] < tree_rank[y]){
            par[x] = y;
        }else{
            par[y] = x;
        }else{
            par[y] = x;
            if(tree_rank[x] == tree_rank[y]) tree_rank[x]++;
        }
    }

snippet gcd
abbr get greatest common divisor
    long long gcd(long long a, long long b){
      int c;
      while ( a != 0 ) {
         c = a; a = b%a; b = c;
      }
      return b;
    }

snippet eratos
abbr get prime list and is_prime list
    const int N = ${0:TARGET};
    bool is_prime[N+1];
    vector<long long> prime;
    void Eratos(){
        for(int i=0; i<N; i++){
            is_prime[i] = true;
        }
        is_prime[0] = is_prime[1] = false;
        for(int i=2; i<=N; i++){
            if(is_prime[i]){
                for(int j=2; i*j<=N; j++){
                    is_prime[i*j] = false;
                }
            }
        }

        for(int i=2; i<=N; i++){
            if(is_prime[i]){
                prime.push_back(i);
            }
        }
    }

snippet dijkstra
abbr get shortest path
    struct edge{int to, cost;};
    typedef pair<int, int> P;

    int n;
    vector<edge> G[MAX_N];
    int d[MAX_N];

    void dijkstra(int s){
        priority_queue<P, vector<P>, greater<P> > que;
        fill(d, d+n, INF);
        d[s] = 0;
        que.push(P(0, s));
    
        while(!que.empty()){
            P p = que.top(); que.pop();
            int v = p.second;
            if(d[v] < p.first) continue;
            for(int i=0; i < G[v].size(); i++){
                edge e = G[v][i];
                if(d[e.to] > d[v] + e.cost){
                    d[e.to] = d[v] + e.cost;
                    que.push(P(d[e.to], e.to));
                }
            }
        }
    }
